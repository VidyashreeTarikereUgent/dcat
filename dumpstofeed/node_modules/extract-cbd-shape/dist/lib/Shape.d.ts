import { Store } from "n3";
import { Term } from "@rdfjs/types";
import { Path } from "./Path";
export declare class NodeLink {
    pathPattern: Path;
    link: Term;
    constructor(pathPattern: Path, link: Term);
}
export declare class ShapeTemplate {
    closed: boolean;
    nodeLinks: Array<NodeLink>;
    requiredPaths: Array<Path>;
    optionalPaths: Array<Path>;
    atLeastOneLists: Array<Array<ShapeTemplate>>;
    constructor();
}
export declare class RDFMap<T> {
    private namedNodes;
    private blankNodes;
    set(node: Term, item: T): void;
    get(node: Term): T | undefined;
}
export declare class ShapesGraph {
    shapes: RDFMap<ShapeTemplate>;
    constructor(shapeStore: Store);
    protected constructPathPattern(shapeStore: Store, listItem: Term): Path;
    /**
     * @param shapeStore
     * @param propertyShapeId
     * @param shape
     * @returns false if it wasn’t a property shape
     */
    protected preprocessPropertyShape(shapeStore: Store, propertyShapeId: Term, shape: ShapeTemplate, required?: boolean): boolean;
    /**
     * Processes a NodeShape or PropertyShape and adds NodeLinks and required properties to the arrays.
     * @param shapeStore
     * @param shapeId
     * @param shape
     * @returns
     */
    preprocessShape(shapeStore: Store, shapeId: Term, shape: ShapeTemplate): true | void;
    /**
     * Processes a NodeShape
     * @param shapeStore
     * @param nodeShapeId
     * @param shape
     */
    protected preprocessNodeShape(shapeStore: Store, nodeShapeId: Term, shape: ShapeTemplate): void;
    /**
     * @param nodeShape is an N3.Store with the quads of the SHACL shape
     */
    initializeFromStore(shapeStore: Store): RDFMap<ShapeTemplate>;
    /**
     * Processes all element from an RDF List, or detects it wasn’t a list after all and it’s just one element.
     * @param shapeStore
     * @param item
     * @returns
     */
    protected rdfListToGenerator(shapeStore: Store, item: Term): Generator<Term>;
    protected rdfListToArray(shapeStore: Store, item: Term): Array<Term>;
}
