import { RdfDereferencer } from "rdf-dereference";
import { ShapesGraph } from "./Shape";
import { Store } from "n3";
import { Quad, Term } from "@rdfjs/types";
/**
 * Usage:
 *  import {ShapeExtractor} from "extract-cbd-shape";
 *  ...
 *  let shapeExtractor = new ShapeExtractor(shape, dereferencer);
 *  let entityquads = await shapeExtractor.extract(store, entity);
 */
export declare class CBDShapeExtractor {
    dereferencer: RdfDereferencer;
    shapesGraph?: ShapesGraph;
    constructor(shapesGraphStore?: Store, dereferencer?: RdfDereferencer);
    loadQuadStreamInStore(store: Store, quadStream: any): Promise<unknown>;
    /**
     * Extracts:
     *  * first level quads,
     *  * their blank nodes with their quads (recursively),
     *  * all quads in the namedgraph of this entity,
     *  * all quads of required paths found in the shape
     *  * the same algorithm on top of all found node links
     * @param store The N3 Store loaded with a set of initial quads
     * @param id The entity to be described/extracted
     * @param shapeId The optional SHACL NodeShape identifier
     * @param graphsToIgnore The optional parameter of graph to ignore when other entities are mentioned in the current context
     * @returns Promise of a quad array of the described entity
     */
    extract(store: Store, id: Term, shapeId?: Term, graphsToIgnore?: Array<Term>): Promise<Array<Quad>>;
    /**
     * Will check whether all required paths work
     */
    private validRequiredPaths;
    /**
     * Given a shape, it will check whether all atLeastOneLists validate
     */
    private validAtLeastOneLists;
    /**
     * Fills the extraPaths and extraNodeLinks parameters with the ones from valid items in the atLeastOneLists
     */
    private recursivelyProcessAtLeastOneLists;
    private extractRecursively;
    /**
     * Performs Concise Bounded Description: extract star-shape and recurses over the blank nodes
     * @param result
     * @param store
     * @param id
     * @param extracted
     */
    CBD(result: Quad[], store: Store, id: Term, extracted: Array<Term>, graphsToIgnore: Array<string>): Promise<void>;
}
