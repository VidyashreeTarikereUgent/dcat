import { NamedNode } from '@rdfjs/types';
declare type RecordOf<TKey extends any[], TValue> = Record<TKey[number], TValue>;
export declare type Namespace<TKey extends any[], TValue, IValue> = {
    namespace: TValue;
    custom: (input: IValue) => TValue;
} & RecordOf<TKey, TValue>;
/**
 * Creates a function that expands local names from the given base URI,
 * and exports the given local names as properties on the returned object.
 */
export declare function createNamespace<TKey extends string, TValue, IValue extends string>(baseUri: string, toValue: (expanded: string) => TValue, ...localNames: TKey[]): Namespace<typeof localNames, TValue, IValue>;
/**
 * Creates a function that expands local names from the given base URI into strings,
 * and exports the given local names as properties on the returned object.
 */
export declare function createUriNamespace<T extends string>(baseUri: string, ...localNames: T[]): Namespace<typeof localNames, string, string>;
/**
 * Creates a function that expands local names from the given base URI into named nodes,
 * and exports the given local names as properties on the returned object.
 */
export declare function createTermNamespace<T extends string>(baseUri: string, ...localNames: T[]): Namespace<typeof localNames, NamedNode, string>;
/**
 * Creates a function that expands local names from the given base URI into string,
 * and exports the given local names as properties on the returned object.
 * Under the `terms` property, it exposes the expanded local names as named nodes.
 */
export declare function createUriAndTermNamespace<T extends string>(baseUri: string, ...localNames: T[]): Namespace<typeof localNames, string, string> & {
    terms: Namespace<typeof localNames, NamedNode, string>;
};
export declare const DC: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("description" | "modified" | "title")[], string> & {
    terms: Namespace<("description" | "modified" | "title")[], NamedNode<string>, string>;
};
export declare const FOAF: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<"Agent"[], string> & {
    terms: Namespace<"Agent"[], NamedNode<string>, string>;
};
export declare const RDF: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("type" | "Class" | "Property" | "nil" | "rest" | "first")[], string> & {
    terms: Namespace<("type" | "Class" | "Property" | "nil" | "rest" | "first")[], NamedNode<string>, string>;
};
export declare const RDFS: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("range" | "Class" | "label" | "comment" | "domain" | "isDefinedBy" | "subClassOf")[], string> & {
    terms: Namespace<("range" | "Class" | "label" | "comment" | "domain" | "isDefinedBy" | "subClassOf")[], NamedNode<string>, string>;
};
export declare const XSD: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("string" | "integer" | "dateTime")[], string> & {
    terms: Namespace<("string" | "integer" | "dateTime")[], NamedNode<string>, string>;
};
export declare const TREE: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("search" | "path" | "node" | "value" | "Collection" | "Relation" | "Node" | "Member" | "member" | "view" | "relation" | "PrefixRelation" | "SubstringRelation" | "SuffixRelation" | "GreaterThanRelation" | "GreaterThanOrEqualRelation" | "LessThanRelation" | "LessThanOrEqualToRelation" | "EqualToRelation" | "GeospatiallyContainsRelation" | "shape" | "ConditionalImport" | "import" | "importStream" | "remainingItems" | "zoom" | "latitudeTile" | "longitudeTile")[], string> & {
    terms: Namespace<("search" | "path" | "node" | "value" | "Collection" | "Relation" | "Node" | "Member" | "member" | "view" | "relation" | "PrefixRelation" | "SubstringRelation" | "SuffixRelation" | "GreaterThanRelation" | "GreaterThanOrEqualRelation" | "LessThanRelation" | "LessThanOrEqualToRelation" | "EqualToRelation" | "GeospatiallyContainsRelation" | "shape" | "ConditionalImport" | "import" | "importStream" | "remainingItems" | "zoom" | "latitudeTile" | "longitudeTile")[], NamedNode<string>, string>;
};
export declare const LDES: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("EventStream" | "timestampPath" | "versionOfPath" | "DurationAgoPolicy" | "Bucketization" | "retentionPolicy" | "amount" | "bucket" | "bucketProperty" | "bucketType" | "LatestVersionSubset" | "BucketizeStrategy")[], string> & {
    terms: Namespace<("EventStream" | "timestampPath" | "versionOfPath" | "DurationAgoPolicy" | "Bucketization" | "retentionPolicy" | "amount" | "bucket" | "bucketProperty" | "bucketType" | "LatestVersionSubset" | "BucketizeStrategy")[], NamedNode<string>, string>;
};
export declare const SDS: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("stream" | "Member" | "relation" | "shape" | "bucket" | "Record" | "ImmutableMember" | "carries" | "dataset" | "Stream" | "payload" | "relationType" | "relationBucket" | "relationValue" | "relationPath")[], string> & {
    terms: Namespace<("stream" | "Member" | "relation" | "shape" | "bucket" | "Record" | "ImmutableMember" | "carries" | "dataset" | "Stream" | "payload" | "relationType" | "relationBucket" | "relationValue" | "relationPath")[], NamedNode<string>, string>;
};
export declare const PROV: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("used" | "startedAtTime" | "wasGeneratedBy")[], string> & {
    terms: Namespace<("used" | "startedAtTime" | "wasGeneratedBy")[], NamedNode<string>, string>;
};
export declare const PPLAN: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<"Activity"[], string> & {
    terms: Namespace<"Activity"[], NamedNode<string>, string>;
};
export declare const VOID: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("Dataset" | "DatasetDescription" | "Linkset" | "TechnicalFeature" | "feature" | "sparqlEndpoint" | "dataDump" | "rootResource" | "exampleResource" | "uriLookupEndpoint" | "openSearchDescription" | "uriSpace" | "uriRegexPattern" | "vocabulary" | "subset" | "propertyPartition" | "triples" | "entities" | "class" | "classes" | "classPartition" | "property" | "properties" | "distinctSubjects" | "distinctObjects" | "documents" | "target" | "subjectsTarget" | "objectsTarget" | "linkPredicate" | "inDataset")[], string> & {
    terms: Namespace<("Dataset" | "DatasetDescription" | "Linkset" | "TechnicalFeature" | "feature" | "sparqlEndpoint" | "dataDump" | "rootResource" | "exampleResource" | "uriLookupEndpoint" | "openSearchDescription" | "uriSpace" | "uriRegexPattern" | "vocabulary" | "subset" | "propertyPartition" | "triples" | "entities" | "class" | "classes" | "classPartition" | "property" | "properties" | "distinctSubjects" | "distinctObjects" | "documents" | "target" | "subjectsTarget" | "objectsTarget" | "linkPredicate" | "inDataset")[], NamedNode<string>, string>;
};
export declare const SHACL: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("name" | "path" | "property" | "NodeShape" | "targetClass" | "alternativePath" | "datatype" | "nodeKind" | "pattern" | "flags" | "minExclusive" | "minInclusive" | "maxExclusive" | "maxInclusive" | "not" | "and" | "or" | "xone" | "in" | "hasValue" | "defaultValue" | "minCount" | "maxCount")[], string> & {
    terms: Namespace<("name" | "path" | "property" | "NodeShape" | "targetClass" | "alternativePath" | "datatype" | "nodeKind" | "pattern" | "flags" | "minExclusive" | "minInclusive" | "maxExclusive" | "maxInclusive" | "not" | "and" | "or" | "xone" | "in" | "hasValue" | "defaultValue" | "minCount" | "maxCount")[], NamedNode<string>, string>;
};
export declare const EX: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<string[], string> & {
    terms: Namespace<string[], NamedNode<string>, string>;
};
export {};
