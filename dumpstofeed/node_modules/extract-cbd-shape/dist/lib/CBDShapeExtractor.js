"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CBDShapeExtractor = void 0;
var rdf_dereference_1 = __importDefault(require("rdf-dereference"));
var Shape_1 = require("./Shape");
var n3_1 = require("n3");
/**
 * Usage:
 *  import {ShapeExtractor} from "extract-cbd-shape";
 *  ...
 *  let shapeExtractor = new ShapeExtractor(shape, dereferencer);
 *  let entityquads = await shapeExtractor.extract(store, entity);
 */
var CBDShapeExtractor = /** @class */ (function () {
    function CBDShapeExtractor(shapesGraphStore, dereferencer) {
        if (!dereferencer) {
            this.dereferencer = rdf_dereference_1.default;
        }
        else {
            this.dereferencer = dereferencer;
        }
        //Pre-process shape
        if (shapesGraphStore) {
            this.shapesGraph = new Shape_1.ShapesGraph(shapesGraphStore);
        }
    }
    CBDShapeExtractor.prototype.loadQuadStreamInStore = function (store, quadStream) {
        return new Promise(function (resolve, reject) {
            store.import(quadStream).on("end", resolve).on("error", reject);
        });
    };
    /**
     * Extracts:
     *  * first level quads,
     *  * their blank nodes with their quads (recursively),
     *  * all quads in the namedgraph of this entity,
     *  * all quads of required paths found in the shape
     *  * the same algorithm on top of all found node links
     * @param store The N3 Store loaded with a set of initial quads
     * @param id The entity to be described/extracted
     * @param shapeId The optional SHACL NodeShape identifier
     * @param graphsToIgnore The optional parameter of graph to ignore when other entities are mentioned in the current context
     * @returns Promise of a quad array of the described entity
     */
    CBDShapeExtractor.prototype.extract = function (store, id, shapeId, graphsToIgnore) {
        return __awaiter(this, void 0, void 0, function () {
            var dontExtractFromGraph, result, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        dontExtractFromGraph = (graphsToIgnore ? graphsToIgnore : []).map(function (item) {
                            return item.value;
                        });
                        return [4 /*yield*/, this.extractRecursively(store, id, [], [], dontExtractFromGraph, shapeId)];
                    case 1:
                        result = (_c.sent()).concat(store.getQuads(null, null, null, id));
                        if (!(result.length === 0)) return [3 /*break*/, 5];
                        //Dereference and try again to extract them from the store
                        console.error("Dereferencing " + id.value + " as there were no quads found at all");
                        _a = this.loadQuadStreamInStore;
                        _b = [store];
                        return [4 /*yield*/, this.dereferencer.dereference(id.value)];
                    case 2: return [4 /*yield*/, _a.apply(this, _b.concat([(_c.sent()).data]))];
                    case 3:
                        _c.sent();
                        return [4 /*yield*/, this.extractRecursively(store, id, [], [id.value], dontExtractFromGraph, shapeId)];
                    case 4:
                        result = (_c.sent()).concat(store.getQuads(null, null, null, id));
                        _c.label = 5;
                    case 5: 
                    //When returning the quad array, remove duplicate triples as CBD, required properties, etc. could have added multiple times the same triple
                    return [2 /*return*/, result.filter(function (value, index, array) {
                            return index === array.findIndex(function (x) { return x.equals(value); });
                        })];
                }
            });
        });
    };
    /**
     * Will check whether all required paths work
     */
    CBDShapeExtractor.prototype.validRequiredPaths = function (store, shape, focusNode, graphsToIgnore) {
        var e_1, _a;
        try {
            for (var _b = __values(shape.requiredPaths), _c = _b.next(); !_c.done; _c = _b.next()) {
                var path = _c.value;
                var matchIterator = path.match(store, focusNode, graphsToIgnore);
                if (matchIterator.next().done) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    /**
     * Given a shape, it will check whether all atLeastOneLists validate
     */
    CBDShapeExtractor.prototype.validAtLeastOneLists = function (store, shape, focusNode, graphsToIgnore) {
        var e_2, _a, e_3, _b;
        try {
            for (var _c = __values(shape.atLeastOneLists), _d = _c.next(); !_d.done; _d = _c.next()) {
                var list = _d.value;
                var atLeastOne = false;
                try {
                    for (var list_1 = (e_3 = void 0, __values(list)), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
                        var item = list_1_1.value;
                        if (this.validRequiredPaths(store, item, focusNode, graphsToIgnore) &&
                            this.validAtLeastOneLists(store, item, focusNode, graphsToIgnore)) {
                            atLeastOne = true;
                            break;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (list_1_1 && !list_1_1.done && (_b = list_1.return)) _b.call(list_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (!atLeastOne) {
                    return false;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return true;
    };
    /**
     * Fills the extraPaths and extraNodeLinks parameters with the ones from valid items in the atLeastOneLists
     */
    CBDShapeExtractor.prototype.recursivelyProcessAtLeastOneLists = function (store, shape, id, extraPaths, extraNodeLinks, graphsToIgnore) {
        var e_4, _a, e_5, _b;
        try {
            for (var _c = __values(shape.atLeastOneLists), _d = _c.next(); !_d.done; _d = _c.next()) {
                var list = _d.value;
                try {
                    for (var list_2 = (e_5 = void 0, __values(list)), list_2_1 = list_2.next(); !list_2_1.done; list_2_1 = list_2.next()) {
                        var item = list_2_1.value;
                        if (this.validRequiredPaths(store, item, id, graphsToIgnore) &&
                            this.validAtLeastOneLists(store, item, id, graphsToIgnore)) {
                            extraPaths.push.apply(extraPaths, __spreadArray([], __read(item.requiredPaths), false));
                            extraPaths.push.apply(extraPaths, __spreadArray([], __read(item.optionalPaths), false));
                            extraNodeLinks.push.apply(extraNodeLinks, __spreadArray([], __read(item.nodeLinks), false));
                            this.recursivelyProcessAtLeastOneLists(store, item, id, extraPaths, extraNodeLinks, graphsToIgnore);
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (list_2_1 && !list_2_1.done && (_b = list_2.return)) _b.call(list_2);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    CBDShapeExtractor.prototype.extractRecursively = function (store, id, extracted, dereferenced, graphsToIgnore, shapeId) {
        return __awaiter(this, void 0, void 0, function () {
            var result, shape, _a, _b, visited_1, extraPaths, extraNodeLinks, _c, _d, path, pathQuads, _e, _f, nodeLink, matches, matches_1, matches_1_1, match, _g, _h, _j, _k, e_6_1, pathQuads, e_7_1;
            var e_8, _l, e_7, _m, e_6, _o;
            return __generator(this, function (_p) {
                switch (_p.label) {
                    case 0:
                        //If it has already been extracted, don’t extract it again: prevents cycles
                        if (extracted.find(function (x) { return x.equals(id); })) {
                            return [2 /*return*/, []];
                        }
                        extracted.push(id);
                        result = [];
                        if (shapeId instanceof Shape_1.ShapeTemplate) {
                            shape = shapeId;
                        }
                        else if (shapeId && this.shapesGraph) {
                            shape = this.shapesGraph.shapes.get(shapeId);
                        }
                        if (!(id.termType === "NamedNode" && shape)) return [3 /*break*/, 3];
                        if (!!(this.validRequiredPaths(store, shape, id, graphsToIgnore) &&
                            this.validAtLeastOneLists(store, shape, id, graphsToIgnore))) return [3 /*break*/, 3];
                        //Need to do an extra HTTP request, probably want to log this somehow (TODO)
                        console.error("Dereferencing " +
                            id.value +
                            " as required paths were not set (or all conditionals were not met)");
                        _a = this.loadQuadStreamInStore;
                        _b = [store];
                        return [4 /*yield*/, this.dereferencer.dereference(id.value)];
                    case 1: return [4 /*yield*/, _a.apply(this, _b.concat([(_p.sent()).data]))];
                    case 2:
                        _p.sent();
                        dereferenced.push(id.value);
                        _p.label = 3;
                    case 3:
                        if (!!!shape) return [3 /*break*/, 18];
                        visited_1 = [];
                        extraPaths = [];
                        extraNodeLinks = [];
                        //Process atLeastOneLists in extraPaths and extra NodeLinks
                        this.recursivelyProcessAtLeastOneLists(store, shape, id, extraPaths, extraNodeLinks, graphsToIgnore);
                        try {
                            for (_c = __values(shape.requiredPaths.concat(shape.optionalPaths, extraPaths)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                path = _d.value;
                                pathQuads = Array.from(path.match(store, id, graphsToIgnore))
                                    .map(function (pathResult) {
                                    //if the shape is open and thus CBD is going to take place, remove the first element from the quads list of the matches, if the subject of that first item is the focusnode (otherwise the first element was a reverse path)
                                    if (!shape.closed &&
                                        pathResult.path[0].subject.value === id.value) {
                                        pathResult.path.shift();
                                    }
                                    return pathResult.path;
                                })
                                    .flat()
                                    .filter(function (quad) {
                                    //Make sure we don’t add quads multiple times
                                    if (!visited_1.find(function (x) { return x.equals(quad); })) {
                                        visited_1.push(quad);
                                        return true;
                                    }
                                    return false;
                                });
                                result = result.concat(pathQuads); //concat all quad paths in the results
                            }
                        }
                        catch (e_8_1) { e_8 = { error: e_8_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_l = _c.return)) _l.call(_c);
                            }
                            finally { if (e_8) throw e_8.error; }
                        }
                        _p.label = 4;
                    case 4:
                        _p.trys.push([4, 16, 17, 18]);
                        _e = __values(shape.nodeLinks.concat(extraNodeLinks)), _f = _e.next();
                        _p.label = 5;
                    case 5:
                        if (!!_f.done) return [3 /*break*/, 15];
                        nodeLink = _f.value;
                        matches = Array.from(nodeLink.pathPattern.match(store, id, graphsToIgnore));
                        _p.label = 6;
                    case 6:
                        _p.trys.push([6, 11, 12, 13]);
                        matches_1 = (e_6 = void 0, __values(matches)), matches_1_1 = matches_1.next();
                        _p.label = 7;
                    case 7:
                        if (!!matches_1_1.done) return [3 /*break*/, 10];
                        match = matches_1_1.value;
                        _h = (_g = result.push).apply;
                        _j = [result];
                        _k = [[]];
                        return [4 /*yield*/, this.extractRecursively(store, match.target, extracted, dereferenced, graphsToIgnore, nodeLink.link)];
                    case 8:
                        _h.apply(_g, _j.concat([__spreadArray.apply(void 0, _k.concat([__read.apply(void 0, [(_p.sent())]), false]))]));
                        _p.label = 9;
                    case 9:
                        matches_1_1 = matches_1.next();
                        return [3 /*break*/, 7];
                    case 10: return [3 /*break*/, 13];
                    case 11:
                        e_6_1 = _p.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 13];
                    case 12:
                        try {
                            if (matches_1_1 && !matches_1_1.done && (_o = matches_1.return)) _o.call(matches_1);
                        }
                        finally { if (e_6) throw e_6.error; }
                        return [7 /*endfinally*/];
                    case 13:
                        pathQuads = Array.from(nodeLink.pathPattern.match(store, id, graphsToIgnore))
                            .map(function (pathResult) {
                            //if the shape is open and thus CBD is going to take place, remove the first element from the quads list of the matches, if the subject of that first item is the focusnode (otherwise the first element was a reverse path)
                            if (!(shape === null || shape === void 0 ? void 0 : shape.closed) &&
                                pathResult.path[0].subject.value === id.value) {
                                pathResult.path.shift();
                            }
                            return pathResult.path;
                        })
                            .flat()
                            .filter(function (quad) {
                            //Make sure we don’t add quads multiple times
                            //There must be a more efficient solution to making sure there’s only one of each triple...
                            if (!visited_1.find(function (x) { return x.equals(quad); })) {
                                visited_1.push(quad);
                                return true;
                            }
                            return false;
                        });
                        result = result.concat.apply(result, __spreadArray([], __read(pathQuads), false)); //concat all quad paths in the results
                        _p.label = 14;
                    case 14:
                        _f = _e.next();
                        return [3 /*break*/, 5];
                    case 15: return [3 /*break*/, 18];
                    case 16:
                        e_7_1 = _p.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 18];
                    case 17:
                        try {
                            if (_f && !_f.done && (_m = _e.return)) _m.call(_e);
                        }
                        finally { if (e_7) throw e_7.error; }
                        return [7 /*endfinally*/];
                    case 18:
                        //Perform CBD and we’re done, except on the condition there’s a shape defined and it’s closed
                        if (!(shape && shape.closed)) {
                            this.CBD(result, store, id, extracted, graphsToIgnore);
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Performs Concise Bounded Description: extract star-shape and recurses over the blank nodes
     * @param result
     * @param store
     * @param id
     * @param extracted
     */
    CBDShapeExtractor.prototype.CBD = function (result, store, id, extracted, graphsToIgnore) {
        return __awaiter(this, void 0, void 0, function () {
            var quads, _loop_1, this_1, quads_1, quads_1_1, q, e_9_1;
            var e_9, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        quads = store.getQuads(id, null, null, null);
                        _loop_1 = function (q) {
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        //ignore quads in the graphs to ignore
                                        if (graphsToIgnore === null || graphsToIgnore === void 0 ? void 0 : graphsToIgnore.includes(q.graph.value)) {
                                            return [2 /*return*/, "continue"];
                                        }
                                        result.push(q);
                                        if (!(q.object instanceof n3_1.BlankNode &&
                                            !extracted.find(function (x) { return x.equals(q.object); }))) return [3 /*break*/, 2];
                                        //only perform CBD again recursively on the blank node
                                        return [4 /*yield*/, this_1.CBD(result, store, q.object, extracted, graphsToIgnore)];
                                    case 1:
                                        //only perform CBD again recursively on the blank node
                                        _c.sent();
                                        extracted.push(q.object);
                                        _c.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        quads_1 = __values(quads), quads_1_1 = quads_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!quads_1_1.done) return [3 /*break*/, 5];
                        q = quads_1_1.value;
                        return [5 /*yield**/, _loop_1(q)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        quads_1_1 = quads_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_9_1 = _b.sent();
                        e_9 = { error: e_9_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (quads_1_1 && !quads_1_1.done && (_a = quads_1.return)) _a.call(quads_1);
                        }
                        finally { if (e_9) throw e_9.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    return CBDShapeExtractor;
}());
exports.CBDShapeExtractor = CBDShapeExtractor;
