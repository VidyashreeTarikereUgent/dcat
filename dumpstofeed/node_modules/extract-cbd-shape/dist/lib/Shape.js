"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapesGraph = exports.RDFMap = exports.ShapeTemplate = exports.NodeLink = void 0;
var n3_1 = require("n3");
var types_1 = require("@treecg/types");
var Path_1 = require("./Path");
var SHACL = (0, types_1.createTermNamespace)("http://www.w3.org/ns/shacl#", "zeroOrMorePath", "zeroOrOnePath", "oneOrMorePath", "inversePath", "alternativePath", "deactivated", "minCount", "path", "node", "closed", "property", "and", "xone", "or", "NodeShape");
//TODO: split this file up between Shape functionality and SHACL to our Shape class conversion steps. Also introduce a ShEx to Shape Template
var NodeLink = /** @class */ (function () {
    function NodeLink(pathPattern, link) {
        this.pathPattern = pathPattern;
        this.link = link;
    }
    return NodeLink;
}());
exports.NodeLink = NodeLink;
var ShapeTemplate = /** @class */ (function () {
    function ShapeTemplate() {
        //All properties will be added, but if a required property is not available, then we need to further look it up
        this.requiredPaths = [];
        //If there’s a nodelink through one of the properties, I want to know what other shape to look up in the shapesgraph from there
        this.nodeLinks = [];
        this.atLeastOneLists = [];
        this.optionalPaths = [];
        this.closed = false; //default value
    }
    return ShapeTemplate;
}());
exports.ShapeTemplate = ShapeTemplate;
var RDFMap = /** @class */ (function () {
    function RDFMap() {
        this.namedNodes = new Map();
        this.blankNodes = new Map();
    }
    RDFMap.prototype.set = function (node, item) {
        if (node.termType === "NamedNode") {
            this.namedNodes.set(node.value, item);
        }
        if (node.termType === "BlankNode") {
            this.blankNodes.set(node.value, item);
        }
    };
    RDFMap.prototype.get = function (node) {
        if (node.termType === "NamedNode") {
            return this.namedNodes.get(node.value);
        }
        if (node.termType === "BlankNode") {
            return this.blankNodes.get(node.value);
        }
    };
    return RDFMap;
}());
exports.RDFMap = RDFMap;
var ShapesGraph = /** @class */ (function () {
    function ShapesGraph(shapeStore) {
        this.shapes = this.initializeFromStore(shapeStore);
    }
    ShapesGraph.prototype.constructPathPattern = function (shapeStore, listItem) {
        var _this = this;
        if (listItem instanceof n3_1.BlankNode) {
            //Look for special types
            var zeroOrMorePathObjects = shapeStore.getObjects(listItem, SHACL.zeroOrMorePath, null);
            var oneOrMorePathObjects = shapeStore.getObjects(listItem, SHACL.oneOrMorePath, null);
            var zeroOrOnePathObjects = shapeStore.getObjects(listItem, SHACL.zeroOrOnePath, null);
            var inversePathObjects = shapeStore.getObjects(listItem, SHACL.inversePath, null);
            var alternativePathObjects = shapeStore.getObjects(listItem, SHACL.alternativePath, null);
            if (zeroOrMorePathObjects[0]) {
                return new Path_1.ZeroOrMorePath(this.constructPathPattern(shapeStore, zeroOrMorePathObjects[0]));
            }
            else if (oneOrMorePathObjects[0]) {
                return new Path_1.OneOrMorePath(this.constructPathPattern(shapeStore, oneOrMorePathObjects[0]));
            }
            else if (zeroOrOnePathObjects[0]) {
                return new Path_1.ZeroOrOnePath(this.constructPathPattern(shapeStore, zeroOrOnePathObjects[0]));
            }
            else if (inversePathObjects[0]) {
                return new Path_1.InversePath(this.constructPathPattern(shapeStore, inversePathObjects[0]));
            }
            else if (alternativePathObjects[0]) {
                var alternativeListArray = this.rdfListToArray(shapeStore, alternativePathObjects[0]).map(function (value) {
                    return _this.constructPathPattern(shapeStore, value);
                });
                return new Path_1.AlternativePath(alternativeListArray);
            }
            else {
                var items = this.rdfListToArray(shapeStore, listItem);
                return new Path_1.SequencePath(items.map(function (x) { return _this.constructPathPattern(shapeStore, x); }));
            }
        }
        return new Path_1.PredicatePath(listItem);
    };
    /**
     * @param shapeStore
     * @param propertyShapeId
     * @param shape
     * @returns false if it wasn’t a property shape
     */
    ShapesGraph.prototype.preprocessPropertyShape = function (shapeStore, propertyShapeId, shape, required) {
        //Skip if shape has been deactivated
        var deactivated = shapeStore.getObjects(propertyShapeId, SHACL.deactivated, null);
        if (deactivated.length > 0 && deactivated[0].value === "true") {
            return true; //Success: doesn’t matter what kind of thing it was, it’s deactivated so let’s just proceed
        }
        var path = shapeStore.getObjects(propertyShapeId, SHACL.path, null)[0];
        //Process the path now and make sure there’s a match function
        if (!path) {
            return false; //this isn’t a property shape...
        }
        var pathPattern = this.constructPathPattern(shapeStore, path);
        var minCount = shapeStore.getObjects(propertyShapeId, SHACL.minCount, null);
        if ((minCount[0] && minCount[0].value !== "0") || required) {
            shape.requiredPaths.push(pathPattern);
        }
        else {
            //TODO: don’t include node links?
            shape.optionalPaths.push(pathPattern);
        }
        // **TODO**: will the sh:or, sh:xone, sh:and, etc. be of use here? It won’t contain any more information about possible properties?
        // Maybe to potentially point to another node, xone a datatype?
        // Does it link to a literal or to a new node?
        var nodeLink = shapeStore.getObjects(propertyShapeId, SHACL.node, null);
        if (nodeLink[0]) {
            shape.nodeLinks.push(new NodeLink(pathPattern, nodeLink[0]));
        }
        //TODO: Can Nodelinks appear in conditionals from here? Probably they can? (same comment as ↑)
        return true; // Success: the property shape has been processed
    };
    /**
     * Processes a NodeShape or PropertyShape and adds NodeLinks and required properties to the arrays.
     * @param shapeStore
     * @param shapeId
     * @param shape
     * @returns
     */
    ShapesGraph.prototype.preprocessShape = function (shapeStore, shapeId, shape) {
        return this.preprocessPropertyShape(shapeStore, shapeId, shape)
            ? true
            : this.preprocessNodeShape(shapeStore, shapeId, shape);
    };
    /**
     * Processes a NodeShape
     * @param shapeStore
     * @param nodeShapeId
     * @param shape
     */
    ShapesGraph.prototype.preprocessNodeShape = function (shapeStore, nodeShapeId, shape) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        var _this = this;
        //Check if it’s closed or open
        var closedIndicator = shapeStore.getObjects(nodeShapeId, SHACL.closed, null)[0];
        if (closedIndicator && closedIndicator.value === "true") {
            shape.closed = true;
        }
        //Process properties if it has any
        var properties = shapeStore.getObjects(nodeShapeId, SHACL.property, null);
        try {
            for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                var prop = properties_1_1.value;
                this.preprocessPropertyShape(shapeStore, prop, shape);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return)) _a.call(properties_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // process sh:and: just add all IDs to this array
            // Process everything you can find nested in AND clauses
            for (var _e = __values(shapeStore.getObjects(nodeShapeId, SHACL.and, null)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var andList = _f.value;
                try {
                    // Try to process it as a property shape
                    //for every andList found, iterate through it and try to preprocess the property shape
                    for (var _g = (e_3 = void 0, __values(this.rdfListToArray(shapeStore, andList))), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var and = _h.value;
                        this.preprocessShape(shapeStore, and, shape);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            //Process zero or more sh:xone and sh:or lists in the same way -- explanation in README why they can be handled in the same way
            for (var _j = __values(shapeStore
                .getObjects(nodeShapeId, SHACL.xone, null)
                .concat(shapeStore.getObjects(nodeShapeId, SHACL.or, null))), _k = _j.next(); !_k.done; _k = _j.next()) {
                var xoneOrOrList = _k.value;
                var atLeastOneList = this.rdfListToArray(shapeStore, xoneOrOrList).map(function (val) {
                    var newShape = new ShapeTemplate();
                    //Create a new shape and process as usual -- but mind that we don’t trigger a circular shape here...
                    _this.preprocessShape(shapeStore, val, newShape);
                    return newShape;
                    //Add this one to the shapesgraph
                });
                shape.atLeastOneLists.push(atLeastOneList);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_d = _j.return)) _d.call(_j);
            }
            finally { if (e_4) throw e_4.error; }
        }
        //And finally, we’re just ignoring sh:not. Don’t process this one
    };
    /**
     * @param nodeShape is an N3.Store with the quads of the SHACL shape
     */
    ShapesGraph.prototype.initializeFromStore = function (shapeStore) {
        var e_5, _a;
        //get all named nodes of entities that are sh:ShapeNodes which we’ll recognize through their use of sh:property (we’ll find other relevant shape nodes later on)
        //TODO: This is a limitation though: we only support NodeShapes with at least one sh:property set? Other NodeShapes in this context are otherwise just meaningless?
        var shapeNodes = []
            .concat(shapeStore.getSubjects(SHACL.property, null, null))
            .concat(shapeStore.getSubjects(types_1.RDF.terms.type, SHACL.NodeShape, null))
            .concat(shapeStore.getObjects(null, SHACL.node, null))
            //DISTINCT
            .filter(function (value, index, array) {
            return array.findIndex(function (x) { return x.equals(value); }) === index;
        });
        var shapes = new RDFMap();
        try {
            for (var shapeNodes_1 = __values(shapeNodes), shapeNodes_1_1 = shapeNodes_1.next(); !shapeNodes_1_1.done; shapeNodes_1_1 = shapeNodes_1.next()) {
                var shapeId = shapeNodes_1_1.value;
                var shape = new ShapeTemplate();
                //Don’t process if shape is deactivated
                var deactivated = shapeStore.getObjects(shapeId, SHACL.deactivated, null);
                if (!(deactivated.length > 0 && deactivated[0].value === "true")) {
                    this.preprocessNodeShape(shapeStore, shapeId, shape);
                    shapes.set(shapeId, shape);
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (shapeNodes_1_1 && !shapeNodes_1_1.done && (_a = shapeNodes_1.return)) _a.call(shapeNodes_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return shapes;
    };
    /**
     * Processes all element from an RDF List, or detects it wasn’t a list after all and it’s just one element.
     * @param shapeStore
     * @param item
     * @returns
     */
    ShapesGraph.prototype.rdfListToGenerator = function (shapeStore, item) {
        var rest;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!shapeStore.getObjects(item, "http://www.w3.org/1999/02/22-rdf-syntax-ns#first", null)[0]) return [3 /*break*/, 5];
                    return [4 /*yield*/, shapeStore.getObjects(item, "http://www.w3.org/1999/02/22-rdf-syntax-ns#first", null)[0]];
                case 1:
                    _a.sent();
                    rest = shapeStore.getObjects(item, "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest", null)[0];
                    _a.label = 2;
                case 2:
                    if (!(rest &&
                        rest.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil")) return [3 /*break*/, 4];
                    return [4 /*yield*/, shapeStore.getObjects(rest, "http://www.w3.org/1999/02/22-rdf-syntax-ns#first", null)[0]];
                case 3:
                    _a.sent();
                    rest = shapeStore.getObjects(rest, "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest", null)[0];
                    return [3 /*break*/, 2];
                case 4: return [3 /*break*/, 7];
                case 5: 
                //it’s not a list, it’s just one element
                return [4 /*yield*/, item];
                case 6:
                    //it’s not a list, it’s just one element
                    _a.sent();
                    _a.label = 7;
                case 7: return [2 /*return*/];
            }
        });
    };
    ShapesGraph.prototype.rdfListToArray = function (shapeStore, item) {
        return Array.from(this.rdfListToGenerator(shapeStore, item));
    };
    return ShapesGraph;
}());
exports.ShapesGraph = ShapesGraph;
