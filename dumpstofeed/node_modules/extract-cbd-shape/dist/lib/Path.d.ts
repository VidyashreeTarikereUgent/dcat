import { Quad, Term } from "@rdfjs/types";
import { Store } from "n3";
export interface Path {
    toString(): string;
    match(store: Store, focusNode: Term, graphsToIgnore?: Array<string>, inverse?: boolean): Generator<PathResult>;
}
export declare class PredicatePath implements Path {
    private predicate;
    constructor(predicate: Term);
    toString(): string;
    match(store: Store, focusNode: Term, graphsToIgnore: Array<string>, inverse?: boolean): Generator<PathResult, any, unknown>;
}
export declare class SequencePath implements Path {
    private sequence;
    constructor(sequence: Path[]);
    private matchNext;
    toString(): string;
    match(store: Store, focusNode: Term, graphsToIgnore: Array<string>, inverse?: boolean): Generator<PathResult, any, unknown>;
}
export declare class AlternativePath implements Path {
    private alternatives;
    constructor(alternatives: Path[]);
    toString(): string;
    match(store: Store, focusNode: Term, graphsToIgnore: Array<string>, inverse?: boolean): Generator<PathResult, any, unknown>;
}
export declare class InversePath implements Path {
    private path;
    constructor(path: Path);
    toString(): string;
    match(store: Store, focusNode: Term, graphsToIgnore: Array<string>, inverse?: boolean): Generator<PathResult, any, unknown>;
}
export declare abstract class MultiPath implements Path {
    protected path: Path;
    private maxCount?;
    protected constructor(path: Path, maxCount?: number);
    abstract filter(times: number, res: PathResult): boolean;
    abstract toString(): string;
    private matchNext;
    match(store: Store, focusNode: Term, graphsToIgnore: Array<string>, inverse?: boolean): Generator<PathResult>;
}
export declare class OneOrMorePath extends MultiPath {
    constructor(path: Path);
    filter(times: number, _res: PathResult): boolean;
    toString(): string;
}
export declare class ZeroOrMorePath extends MultiPath {
    constructor(path: Path);
    filter(_times: number, _res: PathResult): boolean;
    toString(): string;
}
export declare class ZeroOrOnePath extends MultiPath {
    constructor(path: Path);
    filter(times: number, _res: PathResult): boolean;
    toString(): string;
}
export declare class PathResult {
    path: Array<Quad>;
    target: Term;
    constructor(path: Array<Quad>, target: Term);
}
